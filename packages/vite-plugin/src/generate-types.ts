import { promises as fs } from 'fs';
import path from 'path';
import { glob } from './utils/glob.js';

interface GenerateTypesOptions {
  localesDir: string;
  outputFile: string;
}

export async function generateTypes(options: GenerateTypesOptions): Promise<void> {
  const { localesDir, outputFile } = options;
  
  try {
    // Find all locale files
    const pattern = path.join(localesDir, '*.json');
    const files = await glob(pattern);
    
    if (files.length === 0) {
      console.warn('No translation files found');
      return;
    }
    
    // Use the first file (typically 'en.json') as the source of truth
    const sourceFile = files.find(f => f.includes('en.json')) || files[0];
    const content = await fs.readFile(sourceFile, 'utf-8');

    let translations;
    try {
      translations = JSON.parse(content);
    } catch (parseError) {
      throw new Error(
        `Failed to parse JSON in ${sourceFile}: ${parseError instanceof Error ? parseError.message : String(parseError)}`
      );
    }
    
    // Generate TypeScript interface
    const types = generateInterface(translations);
    
    // Create the types file content
    const fileContent = `// Generated by @oxog/i18n-vite
// Do not edit this file manually

export interface Messages {
${types}
}

declare module '@oxog/i18n' {
  interface CustomMessages extends Messages {}
}

declare module '@oxog/i18n-react' {
  interface CustomMessages extends Messages {}
}
`;
    
    // Ensure output directory exists
    const outputDir = path.dirname(outputFile);
    await fs.mkdir(outputDir, { recursive: true });
    
    // Write the types file
    await fs.writeFile(outputFile, fileContent, 'utf-8');
    
  } catch (error) {
    console.error('Failed to generate types:', error);
  }
}

function generateInterface(obj: any, indent = '  '): string {
  const lines: string[] = [];
  
  for (const [key, value] of Object.entries(obj)) {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
    
    if (typeof value === 'string') {
      // Extract parameter types from the translation string
      const paramTypes = extractParamTypes(value);
      const type = paramTypes.length > 0 
        ? `TranslationWithParams<'${escapeString(value)}', { ${paramTypes.join('; ')} }>`
        : `'${escapeString(value)}'`;
      
      lines.push(`${indent}${safeKey}: ${type};`);
    } else if (typeof value === 'object' && value !== null) {
      // Nested object
      lines.push(`${indent}${safeKey}: {`);
      lines.push(generateInterface(value, indent + '  '));
      lines.push(`${indent}};`);
    }
  }
  
  return lines.join('\n');
}

function extractParamTypes(str: string): string[] {
  const params: string[] = [];
  const regex = /\{\{([^}]+)\}\}/g;
  let match;
  
  while ((match = regex.exec(str)) !== null) {
    const [paramName, paramType] = match[1].trim().split(':').map(s => s.trim());
    
    if (paramType) {
      params.push(`${paramName}: ${paramType}`);
    } else {
      params.push(`${paramName}: string | number`);
    }
  }
  
  return params;
}

function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

// Helper type for translations with parameters (currently unused, may be used in future)
// const helperTypes = `
// type TranslationWithParams<T extends string, P> = T;
// `;